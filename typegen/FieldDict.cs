using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace typegen
{
    /*  Super simple utilities to rip out #define XXX ### from a file.
     *  
     *  FieldDict.Build("MySrcFile.h", "MySrcOut.cpp", "FieldTag", "Tag")
     *      or
     *  FieldDict.Build("MySrcFile.h", "MySrcOut.cpp", "MsgID", "Msg")
     *      etc
     * 
     *  Example: process a file containing lists of:
     *      #define ttMyTagName 57512
     *      #define ttMyOtherTag 57513
     *  It will then dump out a source file containing static dictionaries for conversions
     *  to and from string/ID value as wells as function implementations for XXXToName and XXXFromString
     *  
     *  ParseIDHeader(string[]) can be used to extract #define abcdefg #### parts out of files
     */
    public class FieldDict
    {
        public static List<KeyValuePair<string, ushort> > ParseIDHeader(string[] lines)
        {
            List<KeyValuePair<string, ushort>> fields = new List<KeyValuePair<string, ushort>>();

            foreach (var line in lines)
            {
                var trim = line.Trim();
                if (trim.StartsWith("//") || trim.StartsWith("/*"))
                    continue;
                if (trim.StartsWith("#pragma"))
                    continue;
                if (trim.StartsWith("#ifdef") || trim.StartsWith("#ifndef") || trim.StartsWith("#endif") || trim.StartsWith("#elif"))
                    continue;
                if (trim.StartsWith("#define FIELDICT_H"))
                    continue;
                if (trim.Length == 0)
                    continue;

                if (trim.StartsWith("#define "))
                {
                    var tagText = trim.Replace("#define ", "");

                    string tagName = "";

                    int c = 0;
                    for (; c < tagText.Length; ++c)
                    {
                        if (char.IsWhiteSpace(tagText[c]))
                            break;
                        tagName += tagText[c];
                    }

                    while (char.IsWhiteSpace(tagText[c]))
                        ++c;

                    string valueText = "";
                    for (; c < tagText.Length; ++c)
                    {
                        if (char.IsWhiteSpace(tagText[c]))
                            break;
                        valueText += tagText[c];
                    }

                    ushort value = 0;
                    valueText = valueText.Replace("U", "");
                    if (valueText.StartsWith("0x"))
                    {
                        valueText = valueText.Replace("0x", "");
                        value = ushort.Parse(valueText, System.Globalization.NumberStyles.HexNumber);
                    }
                    else
                    {
                        if (ushort.TryParse(valueText, out value) == false)
                        {
                            value = fields.FirstOrDefault(i => i.Key == valueText).Value;
                        }
                    }

                    fields.Add(new KeyValuePair<string, ushort>(tagName, value));
                }
            }

            return fields;
        }

        /// <summary>
        /// Example generator that calls ParseIDHEader and then builds some ToName FromName functions
        /// </summary>
        /// <param name="srcFile">Filepath to read and process</param>
        /// <param name="outFile">Filepath to write the generated code to</param>
        /// <param name="tagTypeName">What the tag datatype is called, ie FieldTag, MsgID, etc</param>
        /// <param name="functionWord">World used in the functions, ie "Tag" for "TagFromName"</param>
        public static void Build(string srcFile, string outFile, string tagTypeName, string functionWord)
        {
            var lines = System.IO.File.ReadAllLines(srcFile);

            var fields = ParseIDHeader(lines);

            StringBuilder sb = new StringBuilder();
            sb.AppendLine("/// AUTOGENERATED CODE - DO NOT MODIFY");
            sb.AppendLine($"/// Generated: {DateTime.Now.ToString()}");
            sb.AppendLine();
            sb.AppendLine($"#include <{tagTypeName}.h>");
            sb.AppendLine("#include <map.h>");
            sb.AppendLine("#include <string.h>");
            sb.AppendLine();

            sb.AppendLine($"static const std::map<std::string, {tagTypeName}> _{functionWord}_from_name = {{");
            foreach (var v in fields)
                sb.AppendLine($"    {{ \"{v.Key}\", {v.Value} }},");
            sb.AppendLine("};");
            sb.AppendLine();
            sb.AppendLine($"FieldTag {functionWord}FromName(const std::string& aName) {{");
            sb.AppendLine($"    auto found = _{functionWord}_from_name.find(aName);");
            sb.AppendLine($"    if (found != _{functionWord}_from_name.end())");
            sb.AppendLine("        return found->second;");
            sb.AppendLine("    return {};");
            sb.AppendLine("}");
            sb.AppendLine();

            sb.AppendLine($"static const std::map<{tagTypeName}, std::string> _{functionWord}_to_name = {{");
            foreach (var v in fields)
                sb.AppendLine($"    {{ {v.Value}, \"{v.Key}\" }},");
            sb.AppendLine("};");
            sb.AppendLine();
            sb.AppendLine($"std::string {functionWord}ToName({tagTypeName} aTag) {{");
            sb.AppendLine($"    auto found = _{functionWord}_to_name.find(aTag);");
            sb.AppendLine($"    if (found != _{functionWord}_to_name.end())");
            sb.AppendLine("        return found->second;");
            sb.AppendLine("    return std::string();");
            sb.AppendLine("}");

            System.IO.File.WriteAllText(outFile, sb.ToString());
        }
    }
}